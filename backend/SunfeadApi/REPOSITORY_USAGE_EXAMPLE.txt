// ========================================
// REPOSITORY PATTERN USAGE EXAMPLE
// ========================================
// This file shows how to register and use the generic repository pattern
// DO NOT compile this file - it's for reference only

using Microsoft.EntityFrameworkCore;
using SunfeadApi.Data;
using SunfeadApi.Data.Entities;
using SunfeadApi.Data.Repositories;
using SunfeadApi.Data.Repositories.Interfaces;

// ========================================
// 1. REGISTRATION IN PROGRAM.CS
// ========================================

var builder = WebApplication.CreateBuilder(args);

// Register DbContext
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection"))
           .UseSnakeCaseNamingConvention());

// Register generic repository for all entities
builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));

// Register your services
builder.Services.AddScoped<ProductService>();
builder.Services.AddScoped<CartService>();
builder.Services.AddScoped<OrderService>();

var app = builder.Build();
app.Run();

// ========================================
// 2. SERVICE IMPLEMENTATION EXAMPLES
// ========================================

// Example 1: Product Service
public class ProductService
{
    private readonly IRepository<Product> _productRepo;
    private readonly IRepository<ProductVariant> _variantRepo;
    private readonly ApplicationDbContext _context;

    public ProductService(
        IRepository<Product> productRepo,
        IRepository<ProductVariant> variantRepo,
        ApplicationDbContext context)
    {
        _productRepo = productRepo;
        _variantRepo = variantRepo;
        _context = context;
    }

    public async Task<Product?> GetProductBySlugAsync(string slug)
    {
        return await _productRepo.FirstOrDefaultAsync(p => p.Slug == slug);
    }

    public async Task<IEnumerable<Product>> GetActiveProductsAsync()
    {
        return await _productRepo.FindAsync(p => p.IsActive);
    }

    public async Task<(IEnumerable<Product> Products, int TotalCount)> GetPagedProductsAsync(
        int pageNumber, 
        int pageSize)
    {
        return await _productRepo.GetPagedAsync(
            pageNumber, 
            pageSize, 
            p => p.IsActive);
    }

    public async Task<Product> CreateProductAsync(Product product)
    {
        await _productRepo.AddAsync(product);
        await _context.SaveChangesAsync(); // Important: Save changes!
        return product;
    }

    public async Task UpdateProductAsync(Product product)
    {
        _productRepo.Update(product);
        await _context.SaveChangesAsync();
    }

    public async Task DeleteProductAsync(Guid productId)
    {
        var product = await _productRepo.GetByIdAsync(productId);
        if (product != null)
        {
            _productRepo.Remove(product); // Soft delete via global filter
            await _context.SaveChangesAsync();
        }
    }
}

// Example 2: Cart Service
public class CartService
{
    private readonly IRepository<Cart> _cartRepo;
    private readonly IRepository<CartItem> _cartItemRepo;
    private readonly ApplicationDbContext _context;

    public CartService(
        IRepository<Cart> cartRepo,
        IRepository<CartItem> cartItemRepo,
        ApplicationDbContext context)
    {
        _cartRepo = cartRepo;
        _cartItemRepo = cartItemRepo;
        _context = context;
    }

    public async Task<Cart?> GetActiveCartAsync(Guid userId)
    {
        // Find the user's cart (assuming one active cart per user)
        return await _cartRepo.FirstOrDefaultAsync(c => c.UserId == userId);
    }

    public async Task AddToCartAsync(Guid userId, Guid variantId, int quantity)
    {
        // Get or create cart
        var cart = await GetActiveCartAsync(userId);
        if (cart == null)
        {
            cart = new Cart { UserId = userId };
            await _cartRepo.AddAsync(cart);
            await _context.SaveChangesAsync(); // Save to get cart ID
        }

        // Check if item already in cart
        var existingItem = await _cartItemRepo.FirstOrDefaultAsync(
            ci => ci.CartId == cart.Id && ci.VariantId == variantId);

        if (existingItem != null)
        {
            existingItem.Quantity += quantity;
            _cartItemRepo.Update(existingItem);
        }
        else
        {
            var newItem = new CartItem
            {
                CartId = cart.Id,
                VariantId = variantId,
                Quantity = quantity
            };
            await _cartItemRepo.AddAsync(newItem);
        }

        await _context.SaveChangesAsync();
    }

    public async Task<IEnumerable<CartItem>> GetCartItemsAsync(Guid cartId)
    {
        return await _cartItemRepo.FindAsync(ci => ci.CartId == cartId);
    }

    public async Task ClearCartAsync(Guid cartId)
    {
        var items = await _cartItemRepo.FindAsync(ci => ci.CartId == cartId);
        _cartItemRepo.RemoveRange(items);
        await _context.SaveChangesAsync();
    }
}

// Example 3: Order Service with Transaction
public class OrderService
{
    private readonly IRepository<Order> _orderRepo;
    private readonly IRepository<OrderItem> _orderItemRepo;
    private readonly IRepository<InventoryBatch> _inventoryRepo;
    private readonly ApplicationDbContext _context;

    public OrderService(
        IRepository<Order> orderRepo,
        IRepository<OrderItem> orderItemRepo,
        IRepository<InventoryBatch> inventoryRepo,
        ApplicationDbContext context)
    {
        _orderRepo = orderRepo;
        _orderItemRepo = orderItemRepo;
        _inventoryRepo = inventoryRepo;
        _context = context;
    }

    public async Task<Order> CreateOrderAsync(CreateOrderDto dto)
    {
        // Use transaction for multiple operations
        using var transaction = await _context.Database.BeginTransactionAsync();
        
        try
        {
            // Create order
            var order = new Order
            {
                UserId = dto.UserId,
                OrderNumber = GenerateOrderNumber(),
                Status = OrderStatus.Pending,
                SubtotalAmount = dto.SubtotalAmount,
                TaxAmount = dto.TaxAmount,
                ShippingAmount = dto.ShippingAmount,
                TotalAmount = dto.TotalAmount
            };
            
            await _orderRepo.AddAsync(order);
            await _context.SaveChangesAsync(); // Save to get order ID

            // Add order items
            foreach (var itemDto in dto.Items)
            {
                var orderItem = new OrderItem
                {
                    OrderId = order.Id,
                    VariantId = itemDto.VariantId,
                    Quantity = itemDto.Quantity,
                    UnitPrice = itemDto.UnitPrice,
                    TotalPrice = itemDto.Quantity * itemDto.UnitPrice
                };
                await _orderItemRepo.AddAsync(orderItem);

                // Reserve inventory (simplified - you'd need more logic here)
                var batch = await _inventoryRepo.FirstOrDefaultAsync(
                    b => b.VariantId == itemDto.VariantId);
                // ... inventory reservation logic
            }

            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return order;
        }
        catch
        {
            await transaction.RollbackAsync();
            throw;
        }
    }

    public async Task<IEnumerable<Order>> GetUserOrdersAsync(Guid userId)
    {
        return await _orderRepo.FindAsync(o => o.UserId == userId);
    }

    public async Task<Order?> GetOrderByNumberAsync(string orderNumber)
    {
        return await _orderRepo.FirstOrDefaultAsync(o => o.OrderNumber == orderNumber);
    }

    private string GenerateOrderNumber()
    {
        return $"ORD-{DateTime.UtcNow:yyyyMMdd}-{Guid.NewGuid().ToString("N").Substring(0, 8).ToUpper()}";
    }
}

// Example 4: Using in a Controller
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly ProductService _productService;

    public ProductsController(ProductService productService)
    {
        _productService = productService;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<Product>>> GetProducts(
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 20)
    {
        var (products, totalCount) = await _productService.GetPagedProductsAsync(page, pageSize);
        
        Response.Headers.Add("X-Total-Count", totalCount.ToString());
        
        return Ok(products);
    }

    [HttpGet("{slug}")]
    public async Task<ActionResult<Product>> GetProductBySlug(string slug)
    {
        var product = await _productService.GetProductBySlugAsync(slug);
        
        if (product == null)
            return NotFound();
        
        return Ok(product);
    }

    [HttpPost]
    public async Task<ActionResult<Product>> CreateProduct(Product product)
    {
        var created = await _productService.CreateProductAsync(product);
        return CreatedAtAction(nameof(GetProductBySlug), new { slug = created.Slug }, created);
    }
}

// ========================================
// KEY POINTS TO REMEMBER
// ========================================
// 1. Always call context.SaveChangesAsync() after repository operations
// 2. Use transactions for multi-repository operations
// 3. Inject ApplicationDbContext alongside repositories if you need SaveChanges
// 4. The generic repository does NOT auto-save - you control when to save
// 5. Global soft-delete filter is automatic - Remove() marks IsDeleted=true
// 6. Use FindAsync() for multiple results, FirstOrDefaultAsync() for single result
// 7. Use GetPagedAsync() for pagination instead of GetAllAsync() on large tables

// ========================================
// ALTERNATIVE: Creating a Simple UnitOfWork
// ========================================

public interface IUnitOfWork : IDisposable
{
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
}

public class UnitOfWork : IUnitOfWork
{
    private readonly ApplicationDbContext _context;

    public UnitOfWork(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        return await _context.SaveChangesAsync(cancellationToken);
    }

    public void Dispose()
    {
        _context.Dispose();
    }
}

// Then register in Program.cs:
// builder.Services.AddScoped<IUnitOfWork, UnitOfWork>();

// And use in services:
public class SomeServiceWithUoW
{
    private readonly IRepository<Product> _products;
    private readonly IUnitOfWork _unitOfWork;

    public SomeServiceWithUoW(IRepository<Product> products, IUnitOfWork unitOfWork)
    {
        _products = products;
        _unitOfWork = unitOfWork;
    }

    public async Task CreateProductAsync(Product product)
    {
        await _products.AddAsync(product);
        await _unitOfWork.SaveChangesAsync(); // Cleaner than injecting DbContext
    }
}
